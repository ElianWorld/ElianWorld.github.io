<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://elianworld.github.io/</id>
    <title>Rain</title>
    <updated>2020-11-25T02:29:42.445Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://elianworld.github.io/"/>
    <link rel="self" href="https://elianworld.github.io/atom.xml"/>
    <subtitle>隔壁超市薯片半价</subtitle>
    <logo>https://elianworld.github.io/images/avatar.png</logo>
    <icon>https://elianworld.github.io/favicon.ico</icon>
    <rights>All rights reserved 2020, Rain</rights>
    <entry>
        <title type="html"><![CDATA[Android内存管理机制]]></title>
        <id>https://elianworld.github.io/post/hBRKwWDB5/</id>
        <link href="https://elianworld.github.io/post/hBRKwWDB5/">
        </link>
        <updated>2020-11-25T02:28:54.000Z</updated>
        <content type="html"><![CDATA[<p>暂存</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Android获取正在运行的应用信息]]></title>
        <id>https://elianworld.github.io/post/VP7LQnWWf/</id>
        <link href="https://elianworld.github.io/post/VP7LQnWWf/">
        </link>
        <updated>2020-11-24T07:01:19.000Z</updated>
        <content type="html"><![CDATA[<hr>
<p>API 26之前使用getRunningServices获取当前系统中正在运行的服务，参考代码：<br>
<code>getSystemService(Context.ACTIVITY_SERVICE)).getRunningServices(Integer.MAX_VALUE)</code></p>
<hr>
<p>API 26之后，对系统服务的使用进行了限制，如果还用以上方法，仅能获取到应用本身正在运行的服务，无法获取到系统其它应用的信息，推荐使用以下方法：</p>
<pre><code>        PackageManager localPackageManager = getPackageManager();
		List localList = localPackageManager.getInstalledPackages(PackageManager.GET_PERMISSIONS);

		for (int i = 0; i &lt; localList.size(); i++) {
			PackageInfo localPackageInfo1 = (PackageInfo) localList.get(i);
			String str1 = localPackageInfo1.packageName.split(&quot;:&quot;)[0];
			if (((ApplicationInfo.FLAG_SYSTEM &amp; localPackageInfo1.applicationInfo.flags) == 0) &amp;&amp; ((ApplicationInfo.FLAG_UPDATED_SYSTEM_APP &amp; localPackageInfo1.applicationInfo.flags) == 0) &amp;&amp; ((ApplicationInfo.FLAG_STOPPED &amp; localPackageInfo1.applicationInfo.flags) == 0)) {
				Log.e(TAG,str1);
			}
		}
</code></pre>
<p>其中</p>
<ul>
<li>
<p><code>(ApplicationInfo.FLAG_SYSTEM &amp; localPackageInfo1.applicationInfo.flags) == 0</code>表示剔除其中获取到的系统服务</p>
</li>
<li>
<p><code>(ApplicationInfo.FLAG_UPDATED_SYSTEM_APP &amp; localPackageInfo1.applicationInfo.flags) == 0)</code>表示从获取的服务列表中剔除系统更新服务</p>
</li>
<li>
<p><code>(ApplicationInfo.FLAG_STOPPED &amp; localPackageInfo1.applicationInfo.flags) == 0)</code>表示剔除其中已经停止的应用</p>
</li>
</ul>
<p>其他剩余的就是正在运行中的非系统服务应用信息了。</p>
<hr>
<p>在实际运行过程中，可以发现获取到的list比真实运行中的应用要多，实际获取到的除了正在运行中的应用信息外，还有桌面组件、状态栏组件等应用信息，这是因为这些组件如果被用户添加到桌面，系统就认为组件所在应用的状态不是STOPPED，按照上文的过滤条件，自然被程序获取到了。</p>
]]></content>
    </entry>
</feed>