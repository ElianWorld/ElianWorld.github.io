<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://elianworld.github.io/</id>
    <title>Rain</title>
    <updated>2020-12-02T01:34:20.199Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://elianworld.github.io/"/>
    <link rel="self" href="https://elianworld.github.io/atom.xml"/>
    <subtitle>隔壁超市薯片半价</subtitle>
    <logo>https://elianworld.github.io/images/avatar.png</logo>
    <icon>https://elianworld.github.io/favicon.ico</icon>
    <rights>All rights reserved 2020, Rain</rights>
    <entry>
        <title type="html"><![CDATA[Android-AppWidget自定义更新]]></title>
        <id>https://elianworld.github.io/post/l8rYtKTpC/</id>
        <link href="https://elianworld.github.io/post/l8rYtKTpC/">
        </link>
        <updated>2020-12-02T01:19:12.000Z</updated>
        <content type="html"><![CDATA[<h5 id="更新周期设置">更新周期设置</h5>
<p>xml/widget-info.xml中updatePeriodMillis表示更新频率，以30分钟为更新周期，该值设置不足30分钟的整倍数时，向上取整，比如设置更新周期2分钟，则真实更新周期就是30分钟【系统为省电做的设计】</p>
<hr>
<p>为支持自定义的更新频率，也就是想什么时候更新就什么时候更新，需要设置updatePeriodMillis为0，然后有以下两种方式设置：</p>
<ul>
<li>自定义service：在WidgetProvider中的onUpdate启动service更新RemoteViews，网上有很多介绍，这里不再重复</li>
<li>代码中使用广播按需更新：<br>
<code>Intent intent = new Intent(this, Widget.class); intent.setAction(Widget_Action); sendBroadcast(intent);</code><br>
在需要更新widget时，发送WidgetProvider中能接收到的广播，然后在WidgetProvider的onReceive更新RemoteViews。</li>
</ul>
<hr>
<h5 id="解决更新完视图桌面组件没有更新的问题">解决更新完视图，桌面组件没有更新的问题</h5>
<p>onReceive打日志，看到接收到广播后，更新了RemoteViews，但是桌面没有及时更新，需要将<code>appWidgetManager.updateAppWidget(appWidgetId, remoteViews)</code>修改成<code>appWidgetManager.updateAppWidget(new ComponentName(context, Widget.class), remoteViews);</code>，就可以在onReceive更新视图后，及时在桌面看到更新后的组件。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Android-AppWidget为不同控件设置不同的点击响应]]></title>
        <id>https://elianworld.github.io/post/YyN1kv1tR/</id>
        <link href="https://elianworld.github.io/post/YyN1kv1tR/">
        </link>
        <updated>2020-11-30T11:13:14.000Z</updated>
        <content type="html"><![CDATA[<p>获取PendingIntent实例：<br>
<code>PendingIntent toastPendingIntent = PendingIntent.getBroadcast(context, 0, toastIntent, PendingIntent.FLAG_UPDATE_CURRENT);</code><br>
当第四个参数设置为PendingIntent.FLAG_UPDATE_CURRENT时，可以为不同控件设置不同的点击响应，但是requestCode需要设置为不同的值，否则，实例会被后面设置的相同的requestCode覆盖。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Android获取正在运行的应用信息]]></title>
        <id>https://elianworld.github.io/post/VP7LQnWWf/</id>
        <link href="https://elianworld.github.io/post/VP7LQnWWf/">
        </link>
        <updated>2020-11-24T07:01:19.000Z</updated>
        <content type="html"><![CDATA[<hr>
<p>API 26之前使用getRunningServices获取当前系统中正在运行的服务，参考代码：<br>
<code>getSystemService(Context.ACTIVITY_SERVICE)).getRunningServices(Integer.MAX_VALUE)</code></p>
<hr>
<p>API 26之后，对系统服务的使用进行了限制，如果还用以上方法，仅能获取到应用本身正在运行的服务，无法获取到系统其它应用的信息，推荐使用以下方法：</p>
<pre><code>        PackageManager localPackageManager = getPackageManager();
		List localList = localPackageManager.getInstalledPackages(PackageManager.GET_PERMISSIONS);

		for (int i = 0; i &lt; localList.size(); i++) {
			PackageInfo localPackageInfo1 = (PackageInfo) localList.get(i);
			String str1 = localPackageInfo1.packageName.split(&quot;:&quot;)[0];
			if (((ApplicationInfo.FLAG_SYSTEM &amp; localPackageInfo1.applicationInfo.flags) == 0) &amp;&amp; ((ApplicationInfo.FLAG_UPDATED_SYSTEM_APP &amp; localPackageInfo1.applicationInfo.flags) == 0) &amp;&amp; ((ApplicationInfo.FLAG_STOPPED &amp; localPackageInfo1.applicationInfo.flags) == 0)) {
				Log.e(TAG,str1);
			}
		}
</code></pre>
<p>其中</p>
<ul>
<li>
<p><code>(ApplicationInfo.FLAG_SYSTEM &amp; localPackageInfo1.applicationInfo.flags) == 0</code>表示剔除其中获取到的系统服务</p>
</li>
<li>
<p><code>(ApplicationInfo.FLAG_UPDATED_SYSTEM_APP &amp; localPackageInfo1.applicationInfo.flags) == 0)</code>表示从获取的服务列表中剔除系统更新服务</p>
</li>
<li>
<p><code>(ApplicationInfo.FLAG_STOPPED &amp; localPackageInfo1.applicationInfo.flags) == 0)</code>表示剔除其中已经停止的应用</p>
</li>
</ul>
<p>其他剩余的就是正在运行中的非系统服务应用信息了。</p>
<hr>
<p>在实际运行过程中，可以发现获取到的list比真实运行中的应用要多，实际获取到的除了正在运行中的应用信息外，还有桌面组件、状态栏组件等应用信息，这是因为这些组件如果被用户添加到桌面，系统就认为组件所在应用的状态不是STOPPED，按照上文的过滤条件，自然被程序获取到了。</p>
]]></content>
    </entry>
</feed>