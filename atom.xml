<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://elianworld.github.io/</id>
    <title>Rain</title>
    <updated>2020-12-02T03:30:58.982Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://elianworld.github.io/"/>
    <link rel="self" href="https://elianworld.github.io/atom.xml"/>
    <subtitle>隔壁超市薯片半价</subtitle>
    <logo>https://elianworld.github.io/images/avatar.png</logo>
    <icon>https://elianworld.github.io/favicon.ico</icon>
    <rights>All rights reserved 2020, Rain</rights>
    <entry>
        <title type="html"><![CDATA[Android系统启动流程]]></title>
        <id>https://elianworld.github.io/post/vfUOk3Sip/</id>
        <link href="https://elianworld.github.io/post/vfUOk3Sip/">
        </link>
        <updated>2020-12-02T03:29:56.000Z</updated>
        <content type="html"><![CDATA[<p>123</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Android内存管理机制]]></title>
        <id>https://elianworld.github.io/post/_nDx3OMQo/</id>
        <link href="https://elianworld.github.io/post/_nDx3OMQo/">
        </link>
        <updated>2020-12-02T02:39:16.000Z</updated>
        <content type="html"><![CDATA[<h4 id="一-综述">一、综述</h4>
<p>按照官网介绍，Android是使用分页和内存映射管理内存，按照内存映射的原理，应用修改的任何内存，都会常驻在RAM中， 应用释放内存的方法有两种：</p>
<ul>
<li>释放对象引用，被垃圾回收器回收内存</li>
<li>系统为其他应用分配内存时，按照一定的管理机制，将其从RAM中换出</li>
</ul>
<p>按照这种原理，对于返回到后台的应用，不需要直接从后台程序中删除，可以防止删除后，重新启动初始化导致更多的内存占用和耗电。</p>
<h4 id="二-内存分配">二、内存分配</h4>
<p>Android系统会在应用关闭后将其保留在内存中，以便用户快速切回到这些应用。因此，通常情况下，Android 设备在运行时几乎没有可用的内存。<br>
系统有两种内存不足时，回收内存的机制：内核交换守护进程（kswapd）和低内存终止守护进程（LMK）。<br>
通常情况下，系统优先适用内核交换守护进程来回收内存，当可用内存过小（低于下限）激活守护进程，可用内存充足（高于上限），守护进程停止回收内存。<br>
内核交换守护进程通过删除内存中未经修改的页面或者将已修改的页面回写到存储器来回收内存。<br>
当kswapd不足以处理内存不足的情况时，系统优先减少可用内存的分配量，如果可用内存还不足，则启动LMK终止内存中的进程来回收内存。LMK按照一定的优先级对进程进行回收。</p>
<h5 id="1-低内存终止守护进程lmk优先级">1、低内存终止守护进程（LMK）优先级</h5>
<ul>
<li>
<p>后台应用：之前运行过且当前不处于活动状态的应用。LMK 将首先从具有最高 oom_adj_score 的应用开始终止后台应用。</p>
</li>
<li>
<p>上一个应用：最近用过的后台应用。上一个应用比后台应用具有更高的优先级（得分更低），因为相比某个后台应用，用户更有可能切换到上一个应用。</p>
</li>
<li>
<p>主屏幕应用：这是启动器应用。终止该应用会使壁纸消失。</p>
</li>
<li>
<p>服务：服务由应用启动，可能包括同步或上传到云端。</p>
</li>
<li>
<p>可觉察的应用：用户可通过某种方式察觉到的非前台应用，例如运行一个显示小界面的搜索进程或听音乐。</p>
</li>
<li>
<p>前台应用：当前正在使用的应用。终止前台应用看起来就像是应用崩溃了，可能会向用户提示设备出了问题。</p>
</li>
<li>
<p>持久性（服务）：这些是设备的核心服务，例如电话和 WLAN。</p>
</li>
<li>
<p>系统：系统进程。这些进程被终止后，手机可能看起来即将重新启动。</p>
</li>
<li>
<p>原生：系统使用的极低级别的进程（例如，kswapd）</p>
</li>
</ul>
<hr>
<p><strong>特别注意：系统设备制造商可以修改LMK回收进程的机制，这会导致一些不同厂商之间的兼容性问题。</strong></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Android-AppWidget自定义更新]]></title>
        <id>https://elianworld.github.io/post/l8rYtKTpC/</id>
        <link href="https://elianworld.github.io/post/l8rYtKTpC/">
        </link>
        <updated>2020-12-02T01:19:12.000Z</updated>
        <content type="html"><![CDATA[<h5 id="更新周期设置">更新周期设置</h5>
<p>xml/widget-info.xml中updatePeriodMillis表示更新频率，以30分钟为更新周期，该值设置不足30分钟的整倍数时，向上取整，比如设置更新周期2分钟，则真实更新周期就是30分钟【系统为省电做的设计】</p>
<hr>
<p>为支持自定义的更新频率，也就是想什么时候更新就什么时候更新，需要设置updatePeriodMillis为0，然后有以下两种方式设置：</p>
<ul>
<li>自定义service：在WidgetProvider中的onUpdate启动service更新RemoteViews，网上有很多介绍，这里不再重复</li>
<li>代码中使用广播按需更新：<br>
<code>Intent intent = new Intent(this, Widget.class); intent.setAction(Widget_Action); sendBroadcast(intent);</code><br>
在需要更新widget时，发送WidgetProvider中能接收到的广播，然后在WidgetProvider的onReceive更新RemoteViews。</li>
</ul>
<hr>
<h5 id="解决更新完视图桌面组件没有更新的问题">解决更新完视图，桌面组件没有更新的问题</h5>
<p>onReceive打日志，看到接收到广播后，更新了RemoteViews，但是桌面没有及时更新，需要将<code>appWidgetManager.updateAppWidget(appWidgetId, remoteViews)</code>修改成<code>appWidgetManager.updateAppWidget(new ComponentName(context, Widget.class), remoteViews);</code>，就可以在onReceive更新视图后，及时在桌面看到更新后的组件。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Android-AppWidget为不同控件设置不同的点击响应]]></title>
        <id>https://elianworld.github.io/post/YyN1kv1tR/</id>
        <link href="https://elianworld.github.io/post/YyN1kv1tR/">
        </link>
        <updated>2020-11-30T11:13:14.000Z</updated>
        <content type="html"><![CDATA[<p>获取PendingIntent实例：<br>
<code>PendingIntent toastPendingIntent = PendingIntent.getBroadcast(context, 0, toastIntent, PendingIntent.FLAG_UPDATE_CURRENT);</code><br>
当第四个参数设置为PendingIntent.FLAG_UPDATE_CURRENT时，可以为不同控件设置不同的点击响应，但是requestCode需要设置为不同的值，否则，实例会被后面设置的相同的requestCode覆盖。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Android获取正在运行的应用信息]]></title>
        <id>https://elianworld.github.io/post/VP7LQnWWf/</id>
        <link href="https://elianworld.github.io/post/VP7LQnWWf/">
        </link>
        <updated>2020-11-24T07:01:19.000Z</updated>
        <content type="html"><![CDATA[<hr>
<p>API 26之前使用getRunningServices获取当前系统中正在运行的服务，参考代码：<br>
<code>getSystemService(Context.ACTIVITY_SERVICE)).getRunningServices(Integer.MAX_VALUE)</code></p>
<hr>
<p>API 26之后，对系统服务的使用进行了限制，如果还用以上方法，仅能获取到应用本身正在运行的服务，无法获取到系统其它应用的信息，推荐使用以下方法：</p>
<pre><code>        PackageManager localPackageManager = getPackageManager();
		List localList = localPackageManager.getInstalledPackages(PackageManager.GET_PERMISSIONS);

		for (int i = 0; i &lt; localList.size(); i++) {
			PackageInfo localPackageInfo1 = (PackageInfo) localList.get(i);
			String str1 = localPackageInfo1.packageName.split(&quot;:&quot;)[0];
			if (((ApplicationInfo.FLAG_SYSTEM &amp; localPackageInfo1.applicationInfo.flags) == 0) &amp;&amp; ((ApplicationInfo.FLAG_UPDATED_SYSTEM_APP &amp; localPackageInfo1.applicationInfo.flags) == 0) &amp;&amp; ((ApplicationInfo.FLAG_STOPPED &amp; localPackageInfo1.applicationInfo.flags) == 0)) {
				Log.e(TAG,str1);
			}
		}
</code></pre>
<p>其中</p>
<ul>
<li>
<p><code>(ApplicationInfo.FLAG_SYSTEM &amp; localPackageInfo1.applicationInfo.flags) == 0</code>表示剔除其中获取到的系统服务</p>
</li>
<li>
<p><code>(ApplicationInfo.FLAG_UPDATED_SYSTEM_APP &amp; localPackageInfo1.applicationInfo.flags) == 0)</code>表示从获取的服务列表中剔除系统更新服务</p>
</li>
<li>
<p><code>(ApplicationInfo.FLAG_STOPPED &amp; localPackageInfo1.applicationInfo.flags) == 0)</code>表示剔除其中已经停止的应用</p>
</li>
</ul>
<p>其他剩余的就是正在运行中的非系统服务应用信息了。</p>
<hr>
<p>在实际运行过程中，可以发现获取到的list比真实运行中的应用要多，实际获取到的除了正在运行中的应用信息外，还有桌面组件、状态栏组件等应用信息，这是因为这些组件如果被用户添加到桌面，系统就认为组件所在应用的状态不是STOPPED，按照上文的过滤条件，自然被程序获取到了。</p>
]]></content>
    </entry>
</feed>